"""Fast Downward Plan Parser.

This module parses plan files generated by Fast Downward and converts them
into structured action sequences.

Author: Yazz Warsame
"""

import re


class PlanParser:
    """Parses Fast Downward plan output into structured action sequences.
    
    Fast Downward outputs plans in SAS+ format with actions like:
    - (pickup-from-table a)
    - (unstack b c)
    - (stack-target a b)
    
    This parser extracts these actions and their parameters for execution.
    """
    
    def __init__(self):
        """Initialize the plan parser."""
        pass
    
    def parse_plan_file(self, plan_file):
        """Parse a Fast Downward plan file.
        
        Args:
            plan_file: Path to sas_plan file generated by Fast Downward.
            
        Returns:
            List of (action_name, parameters) tuples.
            Example: [('unstack', ['A', 'B']), ('stack-target', ['A', 'B'])]
        """
        actions = []
        
        with open(plan_file, 'r') as f:
            for line in f:
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith(';'):
                    continue
                
                # Parse action: (action-name param1 param2 ...)
                # Match format: (word word word ...)
                m = re.match(r'\s*\(\s*([a-z-]+)(?:\s+([^)]+))?\s*\)', line, flags=re.IGNORECASE)
                if m:
                    action_name = m.group(1)
                    params_str = m.group(2) if m.group(2) else ""
                    
                    # Split parameters
                    params = params_str.split() if params_str else []
                    
                    # Normalize parameter names (convert to uppercase)
                    params = [p.upper() for p in params]
                    
                    actions.append((action_name, params))
        
        return actions
    
    def format_action(self, action_name, params):
        """Format an action for display.
        
        Args:
            action_name: Name of the action (e.g., 'stack-target').
            params: List of parameter strings.
            
        Returns:
            Formatted string representation of the action.
        """
        if not params:
            return f"{action_name}()"
        return f"{action_name}({', '.join(params)})"
    
    def plan_to_string(self, actions):
        """Convert a parsed plan to a human-readable string.
        
        Args:
            actions: List of (action_name, parameters) tuples.
            
        Returns:
            Multi-line string with numbered action sequence.
        """
        if not actions:
            return "No actions needed"
        
        lines = []
        for i, (action_name, params) in enumerate(actions, 1):
            formatted = self.format_action(action_name, params)
            lines.append(f"{i}. {formatted}")
        
        return "\n".join(lines)
    
    def validate_plan(self, actions):
        """Perform basic validation on a parsed plan.
        
        Checks for:
        - Empty plan
        - Valid action names
        - Proper parameter counts for each action
        
        Args:
            actions: List of (action_name, parameters) tuples.
            
        Returns:
            Tuple of (is_valid, error_message).
            If valid, error_message is None.
        """
        if not actions:
            return True, None  # Empty plan is valid (no-op)
        
        # Expected parameter counts for each action
        expected_params = {
            'pickup-from-table': 1,
            'putdown-to-table': 1,
            'unstack': 2,
            'stack': 2,
            'stack-target': 2
        }
        
        for i, (action_name, params) in enumerate(actions):
            # Check if action is recognized
            if action_name not in expected_params:
                return False, f"Unknown action '{action_name}' at step {i+1}"
            
            # Check parameter count
            expected = expected_params[action_name]
            actual = len(params)
            if actual != expected:
                return False, f"Action '{action_name}' at step {i+1} expects {expected} parameters, got {actual}"
        
        return True, None